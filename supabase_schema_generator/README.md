# supabase_schema_generator

The code generator for the Supabase Schema Library. This package processes your schema definitions and generates type-safe Dart models (using `freezed`), strongly-typed IDs, and smart select statements.

## Installation

Add this package to your `dev_dependencies` in `pubspec.yaml`:

```yaml
dev_dependencies:
  supabase_schema_generator: latest_version
  build_runner: latest_version
  freezed: latest_version
  json_serializable: latest_version
```

## How it Works

1.  **Define Schema**: You define your schema using `supabase_schema` classes.
2.  **Run lean_builder**: First run `dart run lean_builder build` to generate the base `.supabase.dart` file.
    - This step creates the intermediate file that contains your schema definitions, typed IDs, and select statements
3.  **Run build_runner**: Then run `dart run build_runner build` to process the generated file and create the final models.
    - This step reads the `.supabase.dart` file and generates the final freezed models, JSON serialization, etc.
4.  **Generated Output**: The process produces:
    *   **Base Schema File** (`.supabase.dart`): Contains typed IDs, constants, and select statements
    *   **Freezed Models**: Immutable data classes with JSON serialization (generated by build_runner)
    *   **Typed IDs**: `extension type` wrappers around IDs (e.g., `UserId`) for type safety
    *   **Constants**: Table names, column keys
    *   **Select Columns**: A smart getter `selectColumns` that generates the correct Supabase select string, including nested joins

## Generated Code Example

For a `User` model, it generates:

```dart
extension type UserId._(int id) {
  factory UserId.fromJson(dynamic value) => ...
  int toJson() => id;
}

@freezed
sealed class User with _$User {
  const factory User({
    @JsonKey(name: "id") required UserId id,
    @JsonKey(name: "name") required String name,
    // ...
  }) = _User;

  static const String tableName = "users";
  
  // Smart select string with joins
  static String get selectColumns => 'id,name,...';
}
```

## Complex Types

Nested generic field types are supported and generated into the Freezed factory with the usual `@JsonKey` mapping, e.g.:

```dart
@Schema(tableName: 'products')
class ProductSchema extends SupabaseSchema {
  final variants = Field<List<Map<String, dynamic>>>('variants');
  final options = Field<Map<String, dynamic>>('options');
  final tags = Field<List<String>?>('tags');

  @override
  List<Model> get models => [
    Model('ProductDetailModel').fields([variants, options, tags]),
  ];
}
```
